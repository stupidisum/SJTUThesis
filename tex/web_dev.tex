%# -*- coding: utf-8-unix -*-
%%==================================================
%% chapter02.tex
%%==================================================

%\bibliographystyle{sjtu2}%[此处用于每章都生产参考文献]
\chapter{WEB设计开发理论、技术和工具}
\label{chap:web_dev}
软件工程是研究和应用如何以系统性的、规范化的、可定量的过程化方法去开发和维护软件\supercite{radatz1990ieee}，以及如何把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来的学科。它涉及到程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式等方面。所以本课题首先学习了软件开发尤其是WEB开发的相关理论，调研、比较并选择了一些主流的WEB开发技术和高效的WEB开发工具，以期能够用快速、高效、低成本地完成系统的开发。
\section{设计理论}
本系统在开发速度、可重用性、UI/UE、响应式、实时性等方面具有较高的要求，这就意味着传统的瀑布式开发、CSS+HTML、ajax请求等WEB开发理论不能达到本系统的要求。本章学习的理论可以给开发明确可行性、指明开发的方向、提高效率、减少重复造轮子，从而保证系统的顺利实现。
\subsection{敏捷开发}
敏捷开发有很多种，它们的具体名称、理念、过程、术语都不尽相同，相对于「非敏捷」，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发過程中人的作用。\supercite{beck2013agile}

Clarity是一家创业公司，业务需求变化迅速，人员结构比较精简，因此更加适合用敏捷开发。本系统的软件开发团队由3个人组成，每天早晨与需求方即公司CEO和硬件开发团队进行视频通话来总结前一天的开发进度和确定当天的开发任务，不断地在测试服务器部署新特性（feature）版本和在生产服务器部署热修复（hotfix）版本，每个特性完成后再正式发布（release）到生产服务器上，团队成员吃住同行、分工灵活，每个人都能独当一面。
\subsection{Web Components}
Web Components是一组现在已经被W3C加入HTML和DOM规范的、为Web提供了一套标准组件模型的浏览器新特性，它们的设计理念是把“基于组件的软件工程”\footnote{软件工程的一个分支，是一种基于重用的定义、实现和组合松散的独立组件的软件来开发系统的方法}带到互联网的世界。Web Components主要包括4个特性：
\begin{description}
  \item[自定义元素（Custom Elements）] 定义新的HTML元素的应用程序接口
  \item[影DOM（Shadow DOM）] 兼具封装性和可组合性的DOM和样式
  \item[HTML 引入（HTML Imports）] 可声明的引入HTML文档到其他HTML文档的方法
  \item[HTML 模板（HTML Templates）] 新的<template>\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template}}标签，允许HTML文档包含惰性（延后定义或加载）的DOM块
\end{description}

本系统的软件开发团队接受过良好的软件工程教育，对于重复造轮子这样的事情是坚决抵制的，所以我们对于组件的可重用性要求非常高。虽然本系统最终没有直接使用Web Components的官方实现Polymer，但其中自定义元素、HTML 引入和HTML 模板等特性都是非常有意义的，本系统中使用的Angular和React都有这些理念的原型，本系统在实现组件时也大量使用了这些概念来做到组件的可重用性。

\subsection{Material-design}
Material Design，代号为Quantum Paper\footnote{\url{http://www.androidpolice.com/2014/06/11/exclusive-quantum-paper-and-googles-upcoming-effort-to-make-consistent-ui-simple/}}， 是由Google推出的一种全新的设计语言，旨在为手机、平板、台式机等不同平台提供更加一致且广泛的外观和感觉。Material Design 总体来讲是一种隐喻式的基于纸张和墨水的设计，元素是扁平的、有阴影的，按照各自的高度浮动在背景上方，接缝和阴影让你知道哪些元素是可以触碰到的（操作的）。当你移动或改变它们的高度的时候，感觉是一张纸在被移动，符合人们对三维物体的直觉，与真实的纸不同之处在于Material Design的纸可以智能的伸缩和变形。

Clarity的CEO本人是一名正在读本科的大学生，从创业伊始就对不管是硬件还是软件要求都特别高，在UI方面尤其如此，Material Design是为数不多的能满足他的要求的设计语言。本系统中版本管理模块和Smart City模块都使用了Material Design，深受设计师、程序员和用户喜爱，因为在这套设计语言的基础上，设计师省去了很多繁琐的顾虑，程序员实现时也有比较好的UI库，界面简洁明了，让用户直观地感受到页面上不同层次不同元素的重要性。

\subsection{响应式设计 和 Flex 布局}
响应式设计是一种WEB设计方法，旨在构建出可以提供跨设备的（从桌面电脑到移动设备）拥有最佳的视觉和交互体验的网站，方便用户使用最少的缩放、平移和滚动操作来阅读和浏览。\supercite{marcotte2013responsive}为自动适应浏览者的设备环境，响应式网站使用流式的基于比例的网格布局，弹性的图片和CC3 media queries\footnote{没有正式的中文译名，直译为媒体查询，是CSS中@media规则的扩展}做到了以下几点：
\begin{description}
  \item[流式网格] 流式网格要求页面元素按照如百分比之类的相对单位来缩放而不是传统的如像素或点的绝对单位；
  \item[弹性图片] 为防止图片显示时超出容器范围，弹性图片也按照相对单位来缩放；
  \item[Media queries] Media queries 允许页面上的元素根据显示设备的某种属性来使用不同的样式，这里的属性主要是设备的宽度；
\end{description}

Flex 布局，全称CSS Flex Box Layout，意思为弹性盒状模型布局，它是由W3C在2009年提出的一种新的布局方案，可以简便地、完整地、响应式地实现各种简单或复杂的页面布局，目前所有主流浏览器都支持Flex 布局。

Clarity作为一家创业公司没有那么多精力同时维护不同平台上的应用，因此虽然目前并不要求适配手机，但起码的屏幕宽度兼容是需要的，为将来适配更小的屏幕打好基础。本系统中三个模块都使用了flex布局，从而使得页面上的元素可以随着设备屏幕大小的变化（或浏览器的缩放）而自动伸缩。虽然我们的系统不需要适配手机，但其中版本管理模块因为页面上有比较宽的列表，在窄屏幕上显示不正常，于是采用了响应式设计来避免这个问题。
\subsection{RESTful API设计和Web Socket数据更新}
RESTful 中文名叫“具象状态传输”，全称“Representational state transfer”，它是一种包含一系列同在一个分布式网络系统中协调的组件、连接器和数据元素如何按照不同的角色进行交互的设计原则（或者叫设计风格），旨在促进系统的性能、可扩展性、简单性、可修改性、可读性、便携性和可靠性。\supercite{fielding2002principled,fielding2000architectural}相比于SOAP\footnote{Simple Object Access protocol，简单对象访问协议}和XML-RPC\footnote{XML（标准通用标记语言下的一个子集）远程方法调用}更加简单轻量，在URL处理和Payload编码上更加简洁明了。这套设计原则并不局限于WEB应用程序，只要满足其约束条件的和原则的应用程序或设计就是RESTful。WEB应用程序最重要的REST原则是，客户端和服务器之间的交互在不同请求之间是无状态的，这就意味着服务器可以随时重启并且客户端并不关心连接的是哪台服务器，这十分适合云计算\footnote{提供动态的易扩展的虚拟化计算资源的互联网服务模式}的环境。

WebSocket 是HTML5\footnote{万维网的核心语言、标准通用标记语言下的一个应用超文本标记语言（HTML）的第五次重大修改}中一种新的通信协议，浏览器与服务器通过一个TCP\footnote{即Transmission Control Protocol 传输控制协议}连接上的全双工通信(full-duplex)进行交互，只有一开始的握手需要借助HTTP\footnote{即HyperText Transfer Protocol超文本传输协议，是互联网上应用最为广泛的一种网络协议}请求完成。它使得浏览器可以和网站进行更多更频繁更实时的交互，从而可以摒弃从前通过轮询\footnote{每隔一秒向服务器发送一个HTTP请求来获取最新数据}来获取最新数据却会给服务器带来沉重负担的方法。

Clarity如其他众多创业公司一样，选择使用云服务器来搭载自己的服务，因为其自动扩展的虚拟化资源无论是直接成本还是管理成本都比自己公司搭建服务器低。本系统搭载在AWS云服务器上，无状态交互是可扩展性的一大保障，频繁地增删改查设备等数据资源也需要RESTful，于是设计了一套RESTful风格的API，前端和后端分别遵循API接口来实现。另一方面需要让用户能够实时地看到自己的修改以及空气质量的变化，本系统使用WebSocket来实时地更新数据，前后端分别使用收听和发送相关主题（topic）。
\subsection{Oauth 和 JWT}
OAuth是Open Authorization的简写，它是一个被广泛用作互联网用户使用它们的微软、Google、Facebook、Twitter等账号在不用输入它们的密码的情况下登录到第三方网站的开放授权标准。一般来讲，OAuth提供给客户端一个代表资源拥有者访问服务器资源的“安全访问授权”。它规定了资源拥有者授权第三方访问其服务器资源而无需共享它们的凭据的过程。它是专门为超文本传输协议（HTTP）设计的，本质上OAuth允许一个授权服务器在资源拥有者批准的情况下直接把访问令牌（Access Token）发送到第三方客户端，然后第三方再使用访问令牌来获取资源服务器上被保护的资源。\supercite{hardt4rfc6749}

JWT 是 JSON Web Token的简写，它是一个用来在WEB应用环境下在不同参与者之间传递声明（claims）的开放标准。这些令牌被巧妙地设计成紧凑、URL安全且可用的，最适合使用在浏览器单点登录\footnote{SSO, single sign-on}的情况下。JWT声明被典型地用于在身份提供者和服务提供者或者任何其他业务过程中需要身份的地方之间传递认证用户的身份识别。\supercite{bradley2015json}这些令牌本身也可以被认证和加密。

Clarity虽然业务规模还不大，用户数量也很少，但在安全认证方面也是紧跟行业潮流，为将来接入各种社交账号登录做准备。本系统使用OAuth标准，其中访问令牌（Access Token）使用的是JWT。用户登陆后除了会获得一个对应的访问令牌之外还有一个寿命较长的刷新令牌（Refresh Token）用来在用户短期离线后自动刷新访问令牌，而这一切除了一开始的登录都不需要用户重新输入密码，只有在用户长期离线刷新令牌也过期的情况下才需要再次登录。

\subsection{Flux 架构模式}
Flux 是Facebook用来构建客户端WEB应用的应用架构，它利用一个单向的数据流对React\footnote{会在下一节技术架构中介绍到}的可组合的视图组件进行了有力的补充。它更像是一种模式而不是一个框架，所以在这里本课题认为它属于理论而不是技术。

它与传统的MVC模型\footnote{即Model View Controller，是一种软件设计典范}不同，主要包括三部分：dispatcher、store和view,由action来触发状态（state）变化。如下图所示： 所有的action会进入到dispatcher进行处理，dispatcher会产生新的state用以更新store，store选择恰当的时机更新后通过view提前注册好的消息（回调）来告诉view更新用户界面。但其实大部分情况下action由用户的操作产生，因此会有从view产生的action。

\begin{figure}[!htp]
 \centering
 \includegraphics[width=0.9\textwidth]{flux.png}
 \bicaption[fig:longcaptionbad]{Flux 单向数据流}{Flux 单向数据流}{Fig}{Flux Unidirectional Data Flow}
\end{figure}

单向数据流传输的Flux不会像MVC那样，一旦系统复杂了，model和view之间的联系呈几何级数增长，也不会像双向绑定那样，一旦绑定层数多了，连程序员自己都不清楚状态更新是被哪里触发的。

Clarity致力于给用户最好的体验，因此在给合作方做的Smart Home和Smart City两个模块中使用了Flux架构模式。用户也许会在潜意识里感觉到，他们在我们的应用上看到的状态永远是一致的，不会出现类似明明看到有未读的消息点进去却发现没有的情况。

\section{技术架构}
Clarity的开发团队是一个精简且高效的年轻团队，我们选择了统一而不是分散的技术栈：全栈JavaScript。从前端到后端，从业务逻辑到单元测试，全部使用JS，这样给我们带来了不少好处：
\begin{enumerate*}
  \item 提高了代码重用率，因为前后端可以共同使用一些代码逻辑
  \item 提高了分工灵活度，前后端的人力可以随时支援对方
  \item 提高了开发速度，因为全栈JS的生态圈很强大、包管理系统也非常省心省力
  \item 提高了代码可维护性，因为全栈JS的各种代码规范标准非常强大\ldots
\end{enumerate*}

下面就开始分前端、后端、数据库和服务器来介绍本系统的技术架构：
\subsection{前端： Angular VS React}
目前JS的主流前端技术无外乎两个选择，Angular和React，如图2-2所示，这两个项目在Github上排行分别是第5和第6。
\begin{figure}[!htp]
 \centering
 \includegraphics[width=0.9\textwidth]{github_rank.png}
 \bicaption[fig:longcaptionbad]{Github angular和react排名情况}{Github angular和react排名情况}{Fig}{Github star ranking of angular and react}
\end{figure}
\subsubsection{Angular}
AngularJS 是一个主要由Google维护的开源WEB应用框架，另外还有一个由个人和企业组成的解决SPA\footnote{Single-page applications单页面应用}开发过程中遇到的挑战的社区参与维护。AngularJS旨在通过提供一个客户端MVC架构和MVVM\footnote{model-view-viewmodel}架构的框架来简化SPA的开发和测试，另外它还提供了许多在丰富互联网应用（Rich Internet Application）\footnote{是一种拥有很多桌面应用软件特性的WEB应用 }中被广泛使用的组件（component）。

AngularJS 首先读取预先嵌入了额外的自定义标签和自定义属性的HTML页面，Angular把这些标签和属性解译为一些directive\footnote{AngularJS中对可重用组件的定义}，它们可以把页面上输入和输出的部分绑定到一个标准JavaScript变量模型（model），模型中的值可以在代码中设置或者来自静态或动态的JSON\footnote{JavaScript Object Notation,是一种使用可读的文本来传输以键值对表示的数据对象的开放标准格式}资源。

AngularJS 在2010年首次发布，除了开源，它有一些创举，极大解放了前端工程师以及后端工程师的生产力：
\begin{enumerate}
  \item 使用依赖注入（dependency injection）\footnote{一种使用控制反转来处理依赖管理的软件设计模式}，使得客户端也可以使用MVC，把WEB应用程序的客户端和服务端解耦合了，减轻了原本后端路由控制、页面渲染的负担，使得两边都可以被重用
  \item 使用双向绑定（two-way data binding）\footnote{视图和逻辑中的模型变量（model）互相绑定，牵一发而动全身}，把DOM操作从应用程序逻辑中移除了（或者说尽量避免使用），增强了客户端程序的可测试性和性能；增强了HTML，在HTML标签中插入模型变量（model），使得开发者编写HTML时“所见既所得”。
  \item 提供了一整套构建WEB应用的过程：从UI设计，到业务逻辑，再到测试，大量的可重用组件和强大的生态圈使得开发者大量减少重复造轮子的现象
\end{enumerate}

\subsubsection{React}
ReactJS 是一个用来把视图数据渲染为HTML的开源JavaScript库，它的主要维护者是Facebook、Instagram和一个由个人开发者和企业组成的社区。React视图用以自定义HTML标签形式定义的组件（component）来渲染，这些组件可以也包含其他的组件。React在现代单页面应用开发上给开发者提供了一个这样的模型：
\begin{enumerate*}
  \item 子组件无法直接影响父组件的\footnote{所谓的数据向下流，data flows down}
  \item 当数据有所改变时，高效地更新HTML文档（document）
  \item 干净的组件隔离
\end{enumerate*}

ReactJS 是一个年轻的库，它在2011年被首次部署，在2013年美国JS大会（JSConf US 2013）上被开源，它吸收了很多Angular的优点，同时也发现了Angular的不足，总得来讲，ReactJS有以下几点特性是它如此成功的原因：

\begin{description}
  \item[单向数据流（One-way data flow）] 主要由前文介绍的Flux架构保证，每个组件会收到一些属性（properties）用来渲染到HTML标签中。与Angular的双向绑定不同，组件本身不可直接修改这些属性，只能通过作为属性传入的回调函数来修改，在Flux架构中，就是触发Action，这种原理被叫做“properties flow down actions flow up”。
  \item[虚拟DOM（Virtual DOM）] React构造了一个内存中的DOM缓存，统一计算每次渲染之间的差异，然后高效地对浏览器中的DOM进行差异更新，相比于Angular而言，Angular是监听每个视图模型（model）的变化，然后更新DOM中对应的部分，并没有差异更新的能力。
  \item[JSX\footnote{一种JavaScript的扩展语法，可以在JS代码中方便地引用HTML和使用HTML标签}] JSX允许React很方便地在JS代码中渲染子组件（subcomponents）。与Angular增强HTML不同，React依靠JavaScript本身的强大，更加方便地做到了一样的功能。
\end{description}

不得不提的一点是Angular的团队同样知道这些不足，并开发了Angular2，Angular2在很多方面与React很相似，同时又保留了一些Angular的优点。

\subsubsection{综合比较与选择}
目前来说Angular是2015年的JS宠儿，而React则后来居上，其实Angular2应当能与React媲美，但是在项目研发时，Angular2离可以正式使用还有一段距离，React则已经接近正式发布。

Angular和React最大的不同在于一个是WEB框架，一个是JS库。WEB框架意味着开发一个主流的单页面WEB应用程序所需要的一切\footnote{狭义上的，当然不包括各种开发工具}Angular都提供给你了，而React崇尚小而精，它只提供了最核心的部分，其他部分都由开发者自己从社区中选择或者自己开发组合起来搭建一个WEB应用程序。因此也就带来了Angular和React的一大不同，Angular开发WEB应用程序比较方便快捷，而用React则有更多的选择，可以有更多的个性化定制，更加灵活多变。

\begin{table}[!htpb]
  \bicaption[tab:footnote]{Angular和React的对比}{Angular和React的对比}{Table}{Comparisons between Angular and React}
  \centering
  \begin{threeparttable}[b]
    \begin{tabular}{lcr}
      \toprule
      对比 & Angular & React \\
      \midrule
      灵活度 & 一般  & 灵活多变 \\
      稳定性 & 稳定且成熟  & 接近稳定 \\
      开发速度 & 快 & 一般
      社区    & 强大  & 一般但快速成长 \\
      性能 & 一般 & 很高 \\
      支持Web Component\tnote{1} & 弱 & 强 \\
      视图核心语言 & HTML & JavaScript \\
      页面一致性\tnote{2} & 一般 & 强 \\
      \bottomrule
    \end{tabular}
    \begin{tablenotes}
    \item [1] React设计之初就考虑到对Web Component的支持，而Angular的发布和Web Component概念提出大概是在同一时期.
    \item [2] 在上一节的Flux介绍中提到，Angular的双向绑定可能会导致页面出现一些不一致，而程序员自己都难以定位.
    \end{tablenotes}
  \end{threeparttable}
\end{table}

如表2-1所示，Angular和React在很多方面各有不同，有些并不能分出优劣。

本系统中版本管理模块类似传统的后台管理系统，因此选用了稳定、成熟且开发迅速的Angular；而Smart Home和Smart City模块是给用户定制的，所以选用了灵活度更大，性能更好，页面一致性更高的React。具体使用了哪些技术，在后面对模块的详细设计中会有所介绍。

\subsection{后端： Express VS Koa}

\subsection{数据库： MongoDB和Mongoose}
\subsection{服务器： AWS云服务}

\section{开发工具}
\subsection{IDE: Webstorm VS Atom}
\subsection{版本控制： Git和Git Flow}
\subsection{代码生成： Yeoman和Yeoman Generators}
\subsection{文档生成： JsDoc VS EsDoc}
\subsection{代码质量： Lint工具和Git hooks}
\subsubsection{Eslint}
\subsubsection{Jslint}
\subsubsection{Jscs}
\subsubsection{Stylelint}
\subsubsection{Pre-commit}
\subsection{编译工具： Grunt VS Gulp VS Npm}
\subsection{单元测试： Mocha和Karma}
\subsection{持续集成： Travis-CI VS Solano}


